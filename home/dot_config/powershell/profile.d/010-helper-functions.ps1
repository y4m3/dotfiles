# 010-helper-functions.ps1 - Helper functions for PowerShell profile
# Category: 0xx (Foundation)
# Provides common helper functions used by other profile scripts

# Set alias only if not already defined
function Set-AliasIfNotSet {
    param(
        [string]$Name,
        [string]$Value
    )
    if (-not (Get-Alias -Name $Name -ErrorAction SilentlyContinue)) {
        Set-Alias -Name $Name -Value $Value -Scope Global
    }
}

# Set function alias (for commands with arguments)
function Set-FunctionAliasIfNotSet {
    param(
        [string]$Name,
        [scriptblock]$Command
    )
    if (-not (Get-Command -Name $Name -CommandType Function -ErrorAction SilentlyContinue)) {
        Set-Item -Path "function:global:$Name" -Value $Command
    }
}

# Cache and dot-source init scripts generated by external tools.
# On cache hit: only Test-Path + dot-source (no external process).
# On cache miss: run the command, write output to cache file, then dot-source.
# Version is resolved from Scoop junction target (no external process).
function global:Invoke-CachedInit {
    param(
        [Parameter(Mandatory)][string]$ToolName,
        [Parameter(Mandatory)][string[]]$InitCommand,
        [string]$ScoopAppName
    )

    $cacheDir = [IO.Path]::Combine($HOME, '.cache', 'powershell')

    # Resolve version from Scoop junction (filesystem only, no external process)
    $appName = if ($ScoopAppName) { $ScoopAppName } else { $ToolName }
    $currentLink = [IO.Path]::Combine($HOME, 'scoop', 'apps', $appName, 'current')
    $version = 'unknown'
    if (Test-Path $currentLink) {
        $target = (Get-Item $currentLink).Target
        if ($target) {
            $version = Split-Path $target -Leaf
        }
    }

    $cacheFile = Join-Path $cacheDir "$ToolName-$version.ps1"

    if (Test-Path $cacheFile) {
        . $cacheFile
        return
    }

    # Cache miss: ensure directory exists
    if (-not (Test-Path $cacheDir)) {
        New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
    }

    # Remove stale cache files for this tool
    Get-ChildItem -Path $cacheDir -Filter "$ToolName-*.ps1" -ErrorAction SilentlyContinue |
        Remove-Item -Force

    # Generate init script and write to cache
    $output = & $InitCommand[0] $InitCommand[1..($InitCommand.Length - 1)] | Out-String
    Set-Content -Path $cacheFile -Value $output -Encoding utf8
    . $cacheFile
}

# Register a scriptblock to run once after the first prompt (PowerShell.OnIdle).
# Multiple registrations are executed in order. The event handler and queue are
# cleaned up automatically after the single idle trigger.
function global:Register-DeferredInit {
    param(
        [Parameter(Mandatory)][string]$Name,
        [Parameter(Mandatory)][scriptblock]$ScriptBlock
    )

    if (-not $global:__deferred_inits) {
        $global:__deferred_inits = [ordered]@{}
        Register-EngineEvent -SourceIdentifier PowerShell.OnIdle -MaxTriggerCount 1 -Action {
            foreach ($init in $global:__deferred_inits.GetEnumerator()) {
                try { & $init.Value } catch { Write-Warning "Deferred init '$($init.Key)' failed: $_" }
            }
            Remove-Variable -Name __deferred_inits -Scope Global -ErrorAction SilentlyContinue
        } | Out-Null
    }
    $global:__deferred_inits[$Name] = $ScriptBlock
}

# Remove all cached init scripts to force regeneration on next session.
function global:Reset-ProfileCache {
    $cacheDir = [IO.Path]::Combine($HOME, '.cache', 'powershell')
    if (Test-Path $cacheDir) {
        Remove-Item -Path (Join-Path $cacheDir '*.ps1') -Force
        Write-Host 'Profile cache cleared. Restart your shell to regenerate.' -ForegroundColor Yellow
    } else {
        Write-Host 'No profile cache found.' -ForegroundColor Yellow
    }
}
